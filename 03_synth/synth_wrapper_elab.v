
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 11 2025 06:45:38

// Verification Directory fv/synth_wrapper 

module full_adder(a, b, c_in, s_out, c_out);
  input a, b, c_in;
  output s_out, c_out;
  wire a, b, c_in;
  wire s_out, c_out;
  wire n_3, n_6, n_7;
  xor g1 (n_3, a, b);
  xor g2 (s_out, n_3, c_in);
  and g3 (n_6, a, b);
  and g5 (n_7, c_in, n_3);
  or g6 (c_out, n_6, n_7);
endmodule

module adder(a, b, c_in, s_out, c_out);
  input [3:0] a, b;
  input c_in;
  output [3:0] s_out;
  output c_out;
  wire [3:0] a, b;
  wire c_in;
  wire [3:0] s_out;
  wire c_out;
  wire \carry[0] , \carry[1] , \carry[2] ;
  full_adder fa0(.a (a[0]), .b (b[0]), .c_in (c_in), .s_out (s_out[0]),
       .c_out (\carry[0] ));
  full_adder \genblk1[1].fa (.a (a[1]), .b (b[1]), .c_in (\carry[0] ),
       .s_out (s_out[1]), .c_out (\carry[1] ));
  full_adder \genblk1[2].fa (.a (a[2]), .b (b[2]), .c_in (\carry[1] ),
       .s_out (s_out[2]), .c_out (\carry[2] ));
  full_adder \genblk1[3].fa (.a (a[3]), .b (b[3]), .c_in (\carry[2] ),
       .s_out (s_out[3]), .c_out (c_out));
endmodule

module subtract(a, b, c_in, s_out, c_out);
  input [3:0] a, b;
  input c_in;
  output [3:0] s_out;
  output c_out;
  wire [3:0] a, b;
  wire c_in;
  wire [3:0] s_out;
  wire c_out;
  wire [3:0] b_neg;
  adder u_adder(.a (a), .b (b_neg), .c_in (c_in), .s_out (s_out),
       .c_out (c_out));
  not g1 (b_neg[3], b[3]);
  not g2 (b_neg[2], b[2]);
  not g3 (b_neg[1], b[1]);
  not g4 (b_neg[0], b[0]);
endmodule

module and_gate(a, b, out);
  input [3:0] a, b;
  output [3:0] out;
  wire [3:0] a, b;
  wire [3:0] out;
  and g1 (out[0], a[0], b[0]);
  and g2 (out[1], a[1], b[1]);
  and g3 (out[2], a[2], b[2]);
  and g4 (out[3], a[3], b[3]);
endmodule

module or_gate(a, b, out);
  input [3:0] a, b;
  output [3:0] out;
  wire [3:0] a, b;
  wire [3:0] out;
  or g1 (out[0], a[0], b[0]);
  or g2 (out[1], a[1], b[1]);
  or g3 (out[2], a[2], b[2]);
  or g4 (out[3], a[3], b[3]);
endmodule

module xor_gate(a, b, out);
  input [3:0] a, b;
  output [3:0] out;
  wire [3:0] a, b;
  wire [3:0] out;
  xor g1 (out[0], a[0], b[0]);
  xor g2 (out[1], a[1], b[1]);
  xor g3 (out[2], a[2], b[2]);
  xor g4 (out[3], a[3], b[3]);
endmodule

module not_gate(a, out);
  input [3:0] a;
  output [3:0] out;
  wire [3:0] a;
  wire [3:0] out;
  not g1 (out[3], a[3]);
  not g2 (out[2], a[2]);
  not g3 (out[1], a[1]);
  not g4 (out[0], a[0]);
endmodule

module bmux(ctl, in_0, in_1, z);
  input ctl;
  input [3:0] in_0, in_1;
  output [3:0] z;
  wire ctl;
  wire [3:0] in_0, in_1;
  wire [3:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module lsl(a, b, out);
  input [3:0] a;
  input [1:0] b;
  output [3:0] out;
  wire [3:0] a;
  wire [1:0] b;
  wire [3:0] out;
  wire [3:0] stage1;
  bmux mux_stage1_10_14(.ctl (b[1]), .in_0 (a), .in_1 ({stage1[1:0],
       2'b00}), .z (stage1));
  bmux mux_out_13_14(.ctl (b[0]), .in_0 (stage1), .in_1 ({stage1[2:0],
       1'b0}), .z (out));
endmodule

module lsr(a, b, result);
  input [3:0] a;
  input [1:0] b;
  output [3:0] result;
  wire [3:0] a;
  wire [1:0] b;
  wire [3:0] result;
  wire [3:0] stage1;
  bmux mux_stage1_11_14(.ctl (b[1]), .in_0 (a), .in_1 ({2'b00,
       a[3:2]}), .z (stage1));
  bmux mux_result_14_14(.ctl (b[0]), .in_0 (stage1), .in_1 ({1'b0,
       stage1[3:1]}), .z (result));
endmodule

module case_box(in_0, out_0);
  input [2:0] in_0;
  output [7:0] out_0;
  wire [2:0] in_0;
  wire [7:0] out_0;
  wire n_25, n_27, n_39, n_60, n_61, n_62, n_63, n_64;
  wire n_65, n_66, n_67;
  nand g1 (n_25, n_60, n_61, n_62);
  nand g2 (n_27, n_60, n_61, in_0[0]);
  nand g3 (n_63, n_60, in_0[1], n_62);
  nand g4 (n_64, n_60, in_0[1], in_0[0]);
  nand g5 (n_65, in_0[2], n_61, n_62);
  nand g6 (n_66, in_0[2], n_61, in_0[0]);
  nand g7 (n_67, in_0[2], in_0[1], n_62);
  nand g8 (n_39, in_0[2], in_0[1], in_0[0]);
  not g9 (out_0[7], n_25);
  not g10 (out_0[6], n_27);
  not g11 (out_0[5], n_63);
  not g12 (out_0[4], n_64);
  not g13 (out_0[3], n_65);
  not g14 (out_0[2], n_66);
  not g15 (out_0[1], n_67);
  not g16 (out_0[0], n_39);
  not g17 (n_60, in_0[2]);
  not g18 (n_61, in_0[1]);
  not g19 (n_62, in_0[0]);
endmodule

module mux(ctl, in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7, z);
  input [7:0] ctl;
  input [2:0] in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7;
  output [2:0] z;
  wire [7:0] ctl;
  wire [2:0] in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7;
  wire [2:0] z;
  CDN_mux8 g1(.sel0 (ctl[7]), .data0 (in_0[2]), .sel1 (ctl[6]), .data1
       (in_1[2]), .sel2 (ctl[5]), .data2 (in_2[2]), .sel3 (ctl[4]),
       .data3 (in_3[2]), .sel4 (ctl[3]), .data4 (in_4[2]), .sel5
       (ctl[2]), .data5 (in_5[2]), .sel6 (ctl[1]), .data6 (in_6[2]),
       .sel7 (ctl[0]), .data7 (in_7[2]), .z (z[2]));
  CDN_mux8 g4(.sel0 (ctl[7]), .data0 (in_0[1]), .sel1 (ctl[6]), .data1
       (in_1[1]), .sel2 (ctl[5]), .data2 (in_2[1]), .sel3 (ctl[4]),
       .data3 (in_3[1]), .sel4 (ctl[3]), .data4 (in_4[1]), .sel5
       (ctl[2]), .data5 (in_5[1]), .sel6 (ctl[1]), .data6 (in_6[1]),
       .sel7 (ctl[0]), .data7 (in_7[1]), .z (z[1]));
  CDN_mux8 g5(.sel0 (ctl[7]), .data0 (in_0[0]), .sel1 (ctl[6]), .data1
       (in_1[0]), .sel2 (ctl[5]), .data2 (in_2[0]), .sel3 (ctl[4]),
       .data3 (in_3[0]), .sel4 (ctl[3]), .data4 (in_4[0]), .sel5
       (ctl[2]), .data5 (in_5[0]), .sel6 (ctl[1]), .data6 (in_6[0]),
       .sel7 (ctl[0]), .data7 (in_7[0]), .z (z[0]));
endmodule

module mux_11(ctl, in_0, in_1, in_2, z);
  input [2:0] ctl;
  input in_0, in_1, in_2;
  output z;
  wire [2:0] ctl;
  wire in_0, in_1, in_2;
  wire z;
  CDN_mux3 g1(.sel0 (ctl[2]), .data0 (in_0), .sel1 (ctl[1]), .data1
       (in_1), .sel2 (ctl[0]), .data2 (in_2), .z (z));
endmodule

module bmux_12(ctl, in_0, in_1, z);
  input ctl, in_0, in_1;
  output z;
  wire ctl, in_0, in_1;
  wire z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0), .data1 (in_1), .z (z));
endmodule

module mux_13(ctl, in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7, z);
  input [7:0] ctl;
  input [3:0] in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7;
  output [3:0] z;
  wire [7:0] ctl;
  wire [3:0] in_0, in_1, in_2, in_3, in_4, in_5, in_6, in_7;
  wire [3:0] z;
  CDN_mux8 g1(.sel0 (ctl[7]), .data0 (in_0[3]), .sel1 (ctl[6]), .data1
       (in_1[3]), .sel2 (ctl[5]), .data2 (in_2[3]), .sel3 (ctl[4]),
       .data3 (in_3[3]), .sel4 (ctl[3]), .data4 (in_4[3]), .sel5
       (ctl[2]), .data5 (in_5[3]), .sel6 (ctl[1]), .data6 (in_6[3]),
       .sel7 (ctl[0]), .data7 (in_7[3]), .z (z[3]));
  CDN_mux8 g5(.sel0 (ctl[7]), .data0 (in_0[2]), .sel1 (ctl[6]), .data1
       (in_1[2]), .sel2 (ctl[5]), .data2 (in_2[2]), .sel3 (ctl[4]),
       .data3 (in_3[2]), .sel4 (ctl[3]), .data4 (in_4[2]), .sel5
       (ctl[2]), .data5 (in_5[2]), .sel6 (ctl[1]), .data6 (in_6[2]),
       .sel7 (ctl[0]), .data7 (in_7[2]), .z (z[2]));
  CDN_mux8 g6(.sel0 (ctl[7]), .data0 (in_0[1]), .sel1 (ctl[6]), .data1
       (in_1[1]), .sel2 (ctl[5]), .data2 (in_2[1]), .sel3 (ctl[4]),
       .data3 (in_3[1]), .sel4 (ctl[3]), .data4 (in_4[1]), .sel5
       (ctl[2]), .data5 (in_5[1]), .sel6 (ctl[1]), .data6 (in_6[1]),
       .sel7 (ctl[0]), .data7 (in_7[1]), .z (z[1]));
  CDN_mux8 g7(.sel0 (ctl[7]), .data0 (in_0[0]), .sel1 (ctl[6]), .data1
       (in_1[0]), .sel2 (ctl[5]), .data2 (in_2[0]), .sel3 (ctl[4]),
       .data3 (in_3[0]), .sel4 (ctl[3]), .data4 (in_4[0]), .sel5
       (ctl[2]), .data5 (in_5[0]), .sel6 (ctl[1]), .data6 (in_6[0]),
       .sel7 (ctl[0]), .data7 (in_7[0]), .z (z[0]));
endmodule

module synth_wrapper(clk, rst_n, a, b, op, result, carry);
  input clk, rst_n;
  input [3:0] a, b;
  input [2:0] op;
  output [3:0] result;
  output carry;
  wire clk, rst_n;
  wire [3:0] a, b;
  wire [2:0] op;
  wire [3:0] result;
  wire carry;
  wire [3:0] add_out;
  wire [3:0] sub_out;
  wire [3:0] and_out;
  wire [3:0] or_out;
  wire [3:0] xor_out;
  wire [3:0] not_out;
  wire [3:0] lsl_out;
  wire [3:0] lsr_out;
  wire UNCONNECTED, UNCONNECTED0, UNCONNECTED1, UNCONNECTED2,
       UNCONNECTED3, _X_, add_carry, n_30;
  wire n_34, n_35, n_36, n_37, n_38, n_39, n_40, n_41;
  wire n_42, n_43, n_44, n_45, n_46, n_47, n_48, n_49;
  wire n_50, n_51, n_52, n_65, n_66, n_67, n_68, sub_carry;
  adder u_adder(.a (a), .b (b), .c_in (1'b0), .s_out (add_out), .c_out
       (add_carry));
  subtract u_subtract(.a (a), .b (b), .c_in (1'b1), .s_out (sub_out),
       .c_out (sub_carry));
  and_gate u_and(.a (a), .b (b), .out (and_out));
  or_gate u_or(.a (a), .b (b), .out (or_out));
  xor_gate u_xor(.a (a), .b (b), .out (xor_out));
  not_gate u_not(.a (a), .out (not_out));
  lsl u_lsl(.a (a), .b (b[1:0]), .out (lsl_out));
  lsr u_lsr(.a (a), .b (b[1:0]), .result (lsr_out));
  case_box ctl_op_76_19(.in_0 (op), .out_0 ({n_34, n_35, n_36, n_37,
       n_38, n_39, n_40, n_41}));
  mux mux_carry_reg_76_19(.ctl ({n_34, n_35, n_36, n_37, n_38, n_39,
       n_40, n_41}), .in_0 ({2'b01, _X_}), .in_1 ({2'b10, _X_}), .in_2
       (3'b000), .in_3 (3'b000), .in_4 (3'b000), .in_5 (3'b000), .in_6
       (3'b000), .in_7 (3'b000), .z ({n_43, n_42, n_47}));
  mux_11 mux_carry_reg_76_5(.ctl ({n_44, n_45, n_46}), .in_0
       (add_carry), .in_1 (sub_carry), .in_2 (n_47), .z (n_48));
  bmux_12 mux_carry_reg_71_13(.ctl (n_30), .in_0 (n_48), .in_1 (1'b0),
       .z (UNCONNECTED));
  mux_13 mux_result_reg_76_19(.ctl ({n_34, n_35, n_36, n_37, n_38,
       n_39, n_40, n_41}), .in_0 (add_out), .in_1 (sub_out), .in_2
       (and_out), .in_3 (or_out), .in_4 (xor_out), .in_5 (not_out),
       .in_6 (lsl_out), .in_7 (lsr_out), .z ({n_52, n_51, n_50, n_49}));
  bmux mux_result_reg_71_13(.ctl (n_30), .in_0 ({n_52, n_51, n_50,
       n_49}), .in_1 (4'b0000), .z ({UNCONNECTED3, UNCONNECTED2,
       UNCONNECTED1, UNCONNECTED0}));
  CDN_dc logicX_inst(.cf (1'b0), .dcf (1'b1), .z (_X_));
  nand g7 (n_67, n_42, n_65);
  nand g8 (n_68, n_66, n_43);
  not g9 (n_44, n_67);
  not g10 (n_45, n_68);
  nor g11 (n_46, n_45, n_44);
  not g12 (n_65, n_43);
  not g13 (n_66, n_42);
  not g1 (n_30, rst_n);
  CDN_flop \result_reg_reg[0] (.clk (clk), .d (n_49), .sena (1'b1),
       .aclr (n_30), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[0]));
  CDN_flop \result_reg_reg[1] (.clk (clk), .d (n_50), .sena (1'b1),
       .aclr (n_30), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[1]));
  CDN_flop \result_reg_reg[2] (.clk (clk), .d (n_51), .sena (1'b1),
       .aclr (n_30), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[2]));
  CDN_flop \result_reg_reg[3] (.clk (clk), .d (n_52), .sena (1'b1),
       .aclr (n_30), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (result[3]));
  CDN_flop carry_reg_reg(.clk (clk), .d (n_48), .sena (1'b1), .aclr
       (n_30), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (carry));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_dc(cf, dcf, z);
  input cf, dcf;
  output z;
  wire cf, dcf;
  wire z;
  assign z = dcf ? 1'bx : cf;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX // captures one-hot property of select inputs
module CDN_mux8(sel0, data0, sel1, data1, sel2, data2, sel3, data3,
     sel4, data4, sel5, data5, sel6, data6, sel7, data7, z);
  input sel0, data0, sel1, data1, sel2, data2, sel3, data3, sel4,
       data4, sel5, data5, sel6, data6, sel7, data7;
  output z;
  wire sel0, data0, sel1, data1, sel2, data2, sel3, data3, sel4, data4,
       sel5, data5, sel6, data6, sel7, data7;
  reg  z;
  always 
    @(sel0 or sel1 or sel2 or sel3 or sel4 or sel5 or sel6 or sel7 or
         data0 or data1 or data2 or data3 or data4 or data5 or data6 or
         data7) 
      case ({sel0, sel1, sel2, sel3, sel4, sel5, sel6, sel7})
       8'b10000000: z = data0;
       8'b01000000: z = data1;
       8'b00100000: z = data2;
       8'b00010000: z = data3;
       8'b00001000: z = data4;
       8'b00000100: z = data5;
       8'b00000010: z = data6;
       8'b00000001: z = data7;
       default: z = 1'bX;
      endcase
endmodule
`else
module CDN_mux8(sel0, data0, sel1, data1, sel2, data2, sel3, data3,
     sel4, data4, sel5, data5, sel6, data6, sel7, data7, z);
  input sel0, data0, sel1, data1, sel2, data2, sel3, data3, sel4,
       data4, sel5, data5, sel6, data6, sel7, data7;
  output z;
  wire sel0, data0, sel1, data1, sel2, data2, sel3, data3, sel4, data4,
       sel5, data5, sel6, data6, sel7, data7;
  wire z;
  wire w_0, w_1, w_2, w_3, w_4, w_5, w_6, w_7;
  and a_0 (w_0, sel0, data0);
  and a_1 (w_1, sel1, data1);
  and a_2 (w_2, sel2, data2);
  and a_3 (w_3, sel3, data3);
  and a_4 (w_4, sel4, data4);
  and a_5 (w_5, sel5, data5);
  and a_6 (w_6, sel6, data6);
  and a_7 (w_7, sel7, data7);
  or org (z, w_0, w_1, w_2, w_3, w_4, w_5, w_6, w_7);
endmodule
`endif // ONE_HOT_MUX
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX // captures one-hot property of select inputs
module CDN_mux3(sel0, data0, sel1, data1, sel2, data2, z);
  input sel0, data0, sel1, data1, sel2, data2;
  output z;
  wire sel0, data0, sel1, data1, sel2, data2;
  reg  z;
  always 
    @(sel0 or sel1 or sel2 or data0 or data1 or data2) 
      case ({sel0, sel1, sel2})
       3'b100: z = data0;
       3'b010: z = data1;
       3'b001: z = data2;
       default: z = 1'bX;
      endcase
endmodule
`else
module CDN_mux3(sel0, data0, sel1, data1, sel2, data2, z);
  input sel0, data0, sel1, data1, sel2, data2;
  output z;
  wire sel0, data0, sel1, data1, sel2, data2;
  wire z;
  wire w_0, w_1, w_2;
  and a_0 (w_0, sel0, data0);
  and a_1 (w_1, sel1, data1);
  and a_2 (w_2, sel2, data2);
  or org (z, w_0, w_1, w_2);
endmodule
`endif // ONE_HOT_MUX
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  wire sel0, data0, data1;
  wire z;
  wire inv_sel0, w_0, w_1;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
